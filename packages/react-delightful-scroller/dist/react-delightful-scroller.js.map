{"version":3,"file":"react-delightful-scroller.js","sources":["../src/getBatchedItems.js","../src/Wrapper.js","../src/RenderItemWrapper.js","../src/BatchRenderer.js","../src/useDimensions.js","../src/initializeDimensions.js","../src/useVisibility.js","../src/initializeInitialVisibility.js","../src/useScroll.js","../src/useVisibilityAndDimension.js","../src/getVisibleIndexes.js","../src/Sentinel.js","../src/DefaultRenderers.js","../src/index.js"],"sourcesContent":["export const getBatchedItems = (items, batchSize = 1) => {\n  const batched = [];\n\n  // Faster that clone and splice\n  for (let index = 0; index < items.length; index += batchSize) {\n    const chunk = items.slice(index, index + batchSize);\n    // Do something if you want with the group\n    batched.push(chunk);\n  }\n\n  return batched;\n};\n","import React from \"react\";\n\nexport const Wrapper = React.forwardRef(\n  ({ as = \"div\", style, children }, ref) =>\n    React.createElement(as, { ref, style }, children)\n);\n\nWrapper.displayName = \"Wrapper\";\n","import React from \"react\";\n\n// Don't put equality check for items here!\n// node won't update when other props on Render item changes\n// Might create memory leak/closure issues in react hooks\nexport const RenderItemWrapper = React.memo(({ item, index, RenderItem }) => (\n  <RenderItem item={item} index={index} />\n));\n\nRenderItemWrapper.displayName = \"RenderItemWrapper\";\n","import React from \"react\";\nimport Measure from \"react-measure\";\nimport { Wrapper } from \"./Wrapper\";\nimport { RenderItemWrapper } from \"./RenderItemWrapper\";\n\nexport const BatchRenderer = React.memo(\n  ({\n    batch,\n    index,\n    getItemKey,\n    batchSize,\n    wrapperElement,\n    removeFromDOM,\n    dimensions,\n    setDimension,\n    RenderItem,\n    visible,\n    itemHeight\n  }) => {\n    const hasFixedHeightItems = !!itemHeight;\n    let batchWrapper = null;\n\n    if (visible || !removeFromDOM) {\n      const items = batch.map((item, idx) => {\n        const actualIndex = batchSize * index + idx;\n        const key = getItemKey(item, actualIndex);\n        return (\n          <RenderItemWrapper\n            key={key}\n            item={item}\n            index={actualIndex}\n            RenderItem={RenderItem}\n          />\n        );\n      });\n\n      const itemsBatch = (\n        <Wrapper\n          data-iscroller-batch={index}\n          as={wrapperElement}\n          style={\n            !removeFromDOM ? { visibility: visible ? \"visible\" : \"hidden\" } : {}\n          }\n        >\n          {items}\n        </Wrapper>\n      );\n\n      batchWrapper = hasFixedHeightItems ? (\n        // No need to add resize observer to batch of fixed height items\n        itemsBatch\n      ) : (\n        // Add resize observer to batch of dynamic items\n        <Measure\n          // ScrollHeight is actual height of batch including content margins\n          scroll\n          onResize={contentRect => {\n            setDimension(index, contentRect);\n          }}\n        >\n          {({ measureRef }) =>\n            React.cloneElement(itemsBatch, { ref: measureRef })\n          }\n        </Measure>\n      );\n    } else {\n      batchWrapper = (\n        <div\n          style={{\n            height: dimensions.height\n          }}\n        />\n      );\n    }\n\n    return batchWrapper;\n  }\n  // Don't put equality check for batch items here!\n  // prev batch items changes are reverted if next batch items are changed\n  // Might create memory leak/closure issues in react hooks\n);\n\nBatchRenderer.displayName = \"BatchRenderer\";\n","import { useState, useRef } from \"react\";\n\nexport const useDimensions = (initialValue = []) => {\n  const [dimensions, setDimension] = useState(initialValue);\n  // Set state is async, we need a ref to store intermediate value\n  const intermediate = useRef(null);\n  const wrappedSetDimensions = (index, dimension) => {\n    const newDimensions = [\n      ...((intermediate && intermediate.current) || dimensions)\n    ];\n    const { width, height } = dimension.scroll;\n    newDimensions[index] = { width, height };\n    intermediate.current = newDimensions;\n    setDimension(newDimensions);\n  };\n  return [dimensions, wrappedSetDimensions];\n};\n","export function initializeDimensions({\n  axis,\n  itemHeight,\n  averageItemHeight,\n  batchSize,\n  itemsCount\n}) {\n  return () => {\n    const totalBatches = Math.ceil(itemsCount / batchSize);\n    const estimatedEmptyBatchHeight =\n      axis === \"y\"\n        ? Math.ceil((itemHeight || averageItemHeight) * batchSize)\n        : // TODO - handle other directions\n          0;\n    const initial = [];\n    for (let i = 0; i < totalBatches; i += 1) {\n      initial[i] = { height: estimatedEmptyBatchHeight, width: null };\n    }\n    return initial;\n  };\n}\n","import { useState } from \"react\";\n\nexport function useVisibility(initial = []) {\n  const [visibility, setVisibility] = useState(initial);\n\n  const wrappedSetVisibility = newVisibility => {\n    setVisibility(newVisibility);\n  };\n\n  return [visibility, wrappedSetVisibility];\n}\n","export function initializeInitialVisibility({\n  axis,\n  containerHeight,\n  itemHeight,\n  averageItemHeight,\n  batchSize,\n  itemsCount\n}) {\n  return () => {\n    const totalBatches = Math.ceil(itemsCount / batchSize);\n    const estimatedInitialBatches =\n      axis === \"y\"\n        ? Math.ceil(\n            containerHeight / ((itemHeight || averageItemHeight) * batchSize)\n          )\n        : // TODO - handle other directions\n          0;\n    const initial = [];\n    for (let i = 0; i < totalBatches; i += 1) {\n      initial[i] = i < estimatedInitialBatches;\n    }\n    return initial;\n  };\n}\n","import { useEffect, useRef, useState } from \"react\";\nimport throttle from \"lodash.throttle\";\n\nconst getScrollOffset = (element, axis) => {\n  const { scrollTop, scrollY } = element;\n  if (axis === \"y\") {\n    if (scrollTop !== undefined) {\n      return scrollTop;\n    }\n    return scrollY;\n  }\n  return 0;\n};\n\nexport const useScroll = ({ root, axis }) => {\n  const timeout = useRef(null);\n  const [scrollOffset, setScrollOffset] = useState(0);\n\n  useEffect(() => {\n    const element = root || window;\n    const handler = throttle(() => {\n      // If there's a timer, cancel it\n      if (timeout.current) {\n        window.cancelAnimationFrame(timeout.current);\n      }\n      // Setup the requestAnimationFrame\n      timeout.current = window.requestAnimationFrame(() =>\n        setScrollOffset(getScrollOffset(element, axis))\n      );\n    }, 100);\n    element.addEventListener(\"scroll\", handler, {\n      capture: false,\n      passive: true\n    });\n\n    return () => {\n      if (handler.cancel) {\n        handler.cancel();\n      }\n      window.cancelAnimationFrame(timeout.current);\n      element.removeEventListener(\"scroll\", handler);\n    };\n  }, [axis, root]);\n\n  return scrollOffset;\n};\n","import { useEffect } from \"react\";\nimport { useDimensions } from \"./useDimensions\";\nimport { initializeDimensions } from \"./initializeDimensions\";\nimport { useVisibility } from \"./useVisibility\";\nimport { initializeInitialVisibility } from \"./initializeInitialVisibility\";\nimport { useScroll } from \"./useScroll\";\n\n// Time interval B 'overlaps' A if:\n// B starts after A starts but before A finishes.\n// B starts before A starts and finishes after A starts.\nfunction areOverlapping(A, B) {\n  if (B[0] < A[0]) {\n    return B[1] > A[0];\n  }\n  return B[0] < A[1];\n}\n\nexport const useVisibilityAndDimension = ({\n  root,\n  axis,\n  containerHeight,\n  itemsCount,\n  itemHeight,\n  averageItemHeight,\n  batchSize,\n  batchBufferDistance\n}) => {\n  const [dimensions, setDimension] = useDimensions(\n    initializeDimensions({\n      itemsCount,\n      axis,\n      itemHeight,\n      averageItemHeight,\n      batchSize\n    })\n  );\n  const [visibility, setVisibility] = useVisibility(\n    initializeInitialVisibility({\n      itemsCount,\n      axis,\n      containerHeight,\n      itemHeight,\n      averageItemHeight,\n      batchSize\n    })\n  );\n  const scrollOffset = useScroll({ root, axis });\n\n  useEffect(() => {\n    const renderWindow = [\n      scrollOffset - batchBufferDistance,\n      scrollOffset + containerHeight + batchBufferDistance\n    ];\n    const totalBatches = Math.ceil(itemsCount / batchSize);\n\n    let nextTotal = 0;\n    const nextVisibility = [];\n    for (let i = 0; i < totalBatches; i += 1) {\n      const currentHeight = nextTotal;\n      const nextHeight = nextTotal + dimensions[i].height;\n      nextVisibility[i] = areOverlapping(renderWindow, [\n        currentHeight,\n        nextHeight\n      ]);\n      nextTotal = nextHeight;\n    }\n\n    const visibilityChanged = nextVisibility.some(\n      (e, i) => e !== visibility[i]\n    );\n    if (visibilityChanged) {\n      setVisibility(nextVisibility);\n    }\n  }, [\n    batchSize,\n    containerHeight,\n    setVisibility,\n    dimensions,\n    itemsCount,\n    scrollOffset,\n    visibility,\n    batchBufferDistance\n  ]);\n\n  return [dimensions, visibility, setDimension];\n};\n","export const getVisibleIndexes = visibility => {\n  let start;\n  let end;\n\n  for (let i = 0; i < visibility.length; i += 1) {\n    const v = visibility[i];\n    if (start !== undefined && end !== undefined && !v) {\n      break;\n    }\n    if (start === undefined && v) {\n      start = i;\n    }\n    if (start !== undefined && v) {\n      end = i;\n    }\n  }\n\n  return [start, end];\n};\n","import React, { useRef, useEffect } from \"react\";\n\nexport const Sentinel = ({\n  fetchMoreBufferDistance,\n  onFetchMore,\n  RenderLoader,\n  wrapperElement,\n  items,\n  itemsCount,\n  batchSize,\n  root,\n  axis\n}) => {\n  const ref = useRef(null);\n\n  useEffect(() => {\n    const targetNode = ref.current;\n    const options = {\n      root,\n      rootMargin:\n        axis === \"y\" ? `0px 0px ${fetchMoreBufferDistance}px 0px` : \"0px\",\n      threshold: 0\n    };\n    const callback = ([{ isIntersecting }]) => {\n      if (isIntersecting) {\n        onFetchMore({ size: items.length, itemsCount, batchSize });\n      }\n    };\n    const observer = new IntersectionObserver(callback, options);\n    if (targetNode) {\n      observer.observe(targetNode);\n    }\n\n    return () => {\n      // Stop watching all of its target elements for visibility changes\n      observer.disconnect();\n    };\n  }, [\n    axis,\n    fetchMoreBufferDistance,\n    batchSize,\n    items,\n    onFetchMore,\n    root,\n    itemsCount\n  ]);\n\n  return React.createElement(\n    wrapperElement,\n    {\n      ref\n    },\n    <RenderLoader\n      size={items.length}\n      itemsCount={itemsCount}\n      batchSize={batchSize}\n    />\n  );\n};\n","import React from \"react\";\n\nexport const DefaultRenderContainer = ({ children, forwardRef }) => (\n  <div ref={forwardRef}>{children}</div>\n);\n\nDefaultRenderContainer.displayName = \"DefaultRenderContainer\";\n\n// eslint-disable-next-line no-unused-vars\nexport const DefaultRenderItem = ({ item, index }) => item;\n\nDefaultRenderItem.displayName = \"DefaultRenderItem\";\n\n// eslint-disable-next-line no-unused-vars\nexport const DefaultRenderLoader = ({ items, itemsCount, batchSize }) => null;\n\nDefaultRenderLoader.displayName = \"DefaultRenderLoader\";\n","/**\n * TODO:\n * - Use scrollRestoration to reduce batch creation - https://itsze.ro/blog/2017/04/09/infinite-list-and-react.html\n * - Scroll restoration\n * - Optimize computations\n * - Custom element scroll\n * - More stories\n * - Multiple axis support\n * - Testing\n * - Animatable card story\n */\n\n/**\n * Things learnt\n * React.memo re-renders when context is used\n *   - https://github.com/facebook/react/issues/15156\n * Use requestAnimationFrame instead of throttle on scroll\n *   - https://gist.github.com/paulmillr/3118943\n *   - https://gomakethings.com/debouncing-events-with-requestanimationframe-for-better-performance/\n * react remounts rendered node when ref and functional component reference change in render\n */\nimport React, { memo } from \"react\";\nimport useWindowSize from \"@rehooks/window-size\";\nimport PropTypes from \"prop-types\";\nimport { getBatchedItems } from \"./getBatchedItems\";\nimport { BatchRenderer } from \"./BatchRenderer\";\nimport { useVisibilityAndDimension } from \"./useVisibilityAndDimension\";\nimport { getVisibleIndexes } from \"./getVisibleIndexes\";\nimport { Sentinel } from \"./Sentinel\";\nimport {\n  DefaultRenderItem,\n  DefaultRenderContainer,\n  DefaultRenderLoader\n} from \"./DefaultRenderers\";\n\nconst BaseRenderer = ({\n  containerHeight,\n  items,\n  RenderItem,\n  getItemKey,\n  wrapperElement,\n  forwardRef,\n  RenderContainer,\n  removeFromDOM,\n  root,\n  batchSize,\n  axis,\n  averageItemHeight,\n  itemHeight,\n  itemsCount,\n  batchBufferDistance,\n  onFetchMore,\n  RenderLoader,\n  fetchMoreBufferDistance\n}) => {\n  const [dimensions, visibility, setDimension] = useVisibilityAndDimension({\n    root,\n    axis,\n    containerHeight,\n    itemsCount,\n    itemHeight,\n    averageItemHeight,\n    batchSize,\n    batchBufferDistance\n  });\n\n  const batchedItems = getBatchedItems(items, batchSize);\n  let current = batchedItems;\n  let previous = [];\n  let next = [];\n  let prevHeight;\n  let nextHeight;\n\n  if (removeFromDOM) {\n    const [startIndex, endIndex] = getVisibleIndexes(visibility);\n    previous = batchedItems.slice(0, startIndex);\n    current = batchedItems.slice(startIndex, endIndex + 1);\n    next = batchedItems.slice(endIndex + 1, batchedItems.length);\n\n    prevHeight = previous.reduce((p, c, i) => {\n      const index = i;\n      const dimension = dimensions[index];\n      return p + dimension.height;\n    }, 0);\n\n    nextHeight = next.reduce((p, c, i) => {\n      const index = previous.length + current.length + i;\n      const dimension = dimensions[index];\n      return p + dimension.height;\n    }, 0);\n  }\n\n  const batchedElements = current.map((batch, i) => {\n    const index = previous.length + i;\n    return (\n      <BatchRenderer\n        key={index}\n        batch={batch}\n        index={index}\n        getItemKey={getItemKey}\n        batchSize={batchSize}\n        wrapperElement={wrapperElement}\n        removeFromDOM={removeFromDOM}\n        setDimension={setDimension}\n        RenderItem={RenderItem}\n        dimensions={dimensions[index]}\n        visible={visibility[index]}\n        itemHeight={itemHeight}\n      />\n    );\n  });\n\n  const Container = (\n    <RenderContainer forwardRef={forwardRef}>\n      {prevHeight ? (\n        <div style={{ height: prevHeight, visibility: \"hidden\" }} />\n      ) : null}\n      {batchedElements}\n      {nextHeight ? (\n        <div style={{ height: nextHeight, visibility: \"hidden\" }} />\n      ) : null}\n      {axis === \"y\" && items.length < itemsCount ? (\n        <Sentinel\n          onFetchMore={onFetchMore}\n          fetchMoreBufferDistance={fetchMoreBufferDistance}\n          RenderLoader={RenderLoader}\n          wrapperElement={wrapperElement}\n          items={items}\n          itemsCount={itemsCount}\n          batchSize={batchSize}\n          root={root}\n          axis={axis}\n        />\n      ) : null}\n    </RenderContainer>\n  );\n\n  return Container;\n};\n\nBaseRenderer.displayName = \"BaseRenderer\";\n\nconst WindowContainer = props => {\n  const { innerWidth, innerHeight } = useWindowSize();\n\n  return (\n    <BaseRenderer\n      {...props}\n      containerWidth={innerWidth}\n      containerHeight={innerHeight}\n    />\n  );\n};\n\nconst Entry = (props, ref) => {\n  if (!props.root) {\n    return <WindowContainer {...props} forwardRef={ref} />;\n  }\n\n  // TODO - Custom container\n  return null;\n};\n\nconst DelightfulScroller = memo(React.forwardRef(Entry));\n\nDelightfulScroller.defaultProps = {\n  items: [],\n  itemsCount: 0,\n  RenderItem: DefaultRenderItem,\n  getItemKey: (item, index) => (typeof item === \"string\" ? item : index),\n  wrapperElement: \"div\",\n  RenderContainer: DefaultRenderContainer,\n  removeFromDOM: true,\n  root: null,\n  averageItemHeight: 10,\n  itemHeight: null,\n  axis: \"y\",\n  batchSize: 10,\n  batchBufferDistance: 250,\n  fetchMoreBufferDistance: 500,\n  RenderLoader: DefaultRenderLoader,\n  // eslint-disable-next-line no-unused-vars\n  onFetchMore: ({ items, itemsCount, batchSize }) => {}\n};\n\nDelightfulScroller.propTypes = {\n  items: PropTypes.arrayOf(PropTypes.any),\n  itemsCount: PropTypes.number,\n  RenderItem: PropTypes.elementType,\n  getItemKey: PropTypes.func,\n  wrapperElement: PropTypes.string,\n  RenderContainer: PropTypes.elementType,\n  removeFromDOM: PropTypes.bool,\n  root: PropTypes.element,\n  averageItemHeight: PropTypes.number,\n  itemHeight: PropTypes.number,\n  axis: PropTypes.oneOf([\"y\"]),\n  batchSize: PropTypes.number,\n  batchBufferDistance: PropTypes.number,\n  fetchMoreBufferDistance: PropTypes.number,\n  RenderLoader: PropTypes.elementType,\n  onFetchMore: PropTypes.func\n};\n\nDelightfulScroller.displayName = \"DelightfulScroller\";\n\nexport default DelightfulScroller;\n"],"names":["getBatchedItems","items","batchSize","batched","index","length","chunk","slice","push","Wrapper","React","forwardRef","ref","as","style","children","createElement","displayName","RenderItemWrapper","memo","item","RenderItem","BatchRenderer","batch","getItemKey","wrapperElement","removeFromDOM","dimensions","setDimension","visible","hasFixedHeightItems","itemHeight","batchWrapper","map","idx","actualIndex","key","itemsBatch","visibility","Measure","scroll","onResize","contentRect","measureRef","cloneElement","height","useDimensions","initialValue","useState","intermediate","useRef","wrappedSetDimensions","dimension","newDimensions","current","width","initializeDimensions","axis","averageItemHeight","itemsCount","totalBatches","Math","ceil","estimatedEmptyBatchHeight","initial","i","useVisibility","setVisibility","newVisibility","initializeInitialVisibility","containerHeight","estimatedInitialBatches","getScrollOffset","element","scrollTop","scrollY","undefined","useScroll","root","timeout","scrollOffset","setScrollOffset","useEffect","window","handler","throttle","cancelAnimationFrame","requestAnimationFrame","addEventListener","capture","passive","cancel","removeEventListener","areOverlapping","A","B","useVisibilityAndDimension","batchBufferDistance","renderWindow","nextTotal","nextVisibility","currentHeight","nextHeight","some","e","getVisibleIndexes","start","end","v","Sentinel","fetchMoreBufferDistance","onFetchMore","RenderLoader","targetNode","options","rootMargin","threshold","observer","IntersectionObserver","isIntersecting","size","observe","disconnect","DefaultRenderContainer","DefaultRenderItem","DefaultRenderLoader","BaseRenderer","prevHeight","RenderContainer","batchedItems","previous","next","startIndex","endIndex","reduce","p","c","batchedElements","WindowContainer","props","useWindowSize","innerWidth","innerHeight","containerWidth","Entry","DelightfulScroller","defaultProps","propTypes","PropTypes","arrayOf","any","number","elementType","func","string","bool","oneOf"],"mappings":"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"}