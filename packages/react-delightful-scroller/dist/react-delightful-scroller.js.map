{"version":3,"file":"react-delightful-scroller.js","sources":["../src/delightful-scroller/getBatchedItems.js","../src/delightful-scroller/Wrapper.js","../src/delightful-scroller/RenderItemWrapper.js","../src/delightful-scroller/BatchRenderer.js","../src/delightful-scroller/useDimensions.js","../src/delightful-scroller/initializeDimensions.js","../src/delightful-scroller/useVisibility.js","../src/delightful-scroller/initializeInitialVisibility.js","../src/delightful-scroller/useScroll.js","../src/delightful-scroller/useVisibilityAndDimension.js","../src/delightful-scroller/getVisibleIndexes.js","../src/delightful-scroller/Sentinel.js","../src/delightful-scroller/index.js"],"sourcesContent":["export const getBatchedItems = (items, batchSize = 1) => {\n  const batched = [];\n\n  // Faster that clone and splice\n  for (let index = 0; index < items.length; index += batchSize) {\n    const chunk = items.slice(index, index + batchSize);\n    // Do something if you want with the group\n    batched.push(chunk);\n  }\n\n  return batched;\n};\n","import React from \"react\";\n\nexport const Wrapper = React.forwardRef(\n  ({ as = \"div\", style, children }, ref) =>\n    React.createElement(as, { ref, style }, children)\n);\n\nWrapper.displayName = \"Wrapper\";\n","import React from \"react\";\n\nexport const RenderItemWrapper = React.memo(\n  ({ item, index, RenderItem }) => <RenderItem item={item} index={index} />,\n  ({ item: prevItem }, { item }) => prevItem === item\n);\n\nRenderItemWrapper.displayName = \"RenderItemWrapper\";\n","import React from \"react\";\nimport Measure from \"react-measure\";\nimport { Wrapper } from \"./Wrapper\";\nimport { RenderItemWrapper } from \"./RenderItemWrapper\";\n\nexport const BatchRenderer = React.memo(\n  ({\n    batch,\n    index,\n    getItemKey,\n    batchSize,\n    wrapperElement,\n    removeFromDOM,\n    dimensions,\n    setDimension,\n    RenderItem,\n    visible,\n    itemHeight\n  }) => {\n    const hasFixedHeightItems = !!itemHeight;\n    let batchWrapper = null;\n\n    if (visible || !removeFromDOM) {\n      const items = batch.map((item, idx) => {\n        const actualIndex = batchSize * index + idx;\n        const key = getItemKey(item, actualIndex);\n        return (\n          <RenderItemWrapper\n            key={key}\n            item={item}\n            index={actualIndex}\n            RenderItem={RenderItem}\n          />\n        );\n      });\n\n      const itemsBatch = (\n        <Wrapper\n          data-iscroller-batch={index}\n          as={wrapperElement}\n          style={\n            !removeFromDOM ? { visibility: visible ? \"visible\" : \"hidden\" } : {}\n          }\n        >\n          {items}\n        </Wrapper>\n      );\n\n      batchWrapper = hasFixedHeightItems ? (\n        // No need to add resize observer to batch of fixed height items\n        itemsBatch\n      ) : (\n        // Add resize observer to batch of dynamic items\n        <Measure\n          // ScrollHeight is actual height of batch including content margins\n          scroll\n          onResize={contentRect => {\n            setDimension(index, contentRect);\n          }}\n        >\n          {({ measureRef }) =>\n            React.cloneElement(itemsBatch, { ref: measureRef })\n          }\n        </Measure>\n      );\n    } else {\n      batchWrapper = (\n        <div\n          style={{\n            height: dimensions.height\n          }}\n        />\n      );\n    }\n\n    return batchWrapper;\n  },\n  ({ batch: prevBatch, visible: prevVisible }, { batch, visible }) => {\n    const batchItemsHaveSameRef =\n      prevBatch.length === batch.length &&\n      prevBatch.every((e, i) => e === batch[i]);\n\n    return batchItemsHaveSameRef && prevVisible === visible;\n  }\n);\n\nBatchRenderer.displayName = \"BatchRenderer\";\n","import { useState, useRef } from \"react\";\n\nexport const useDimensions = (initialValue = []) => {\n  const [dimensions, setDimension] = useState(initialValue);\n  // Set state is async, we need a ref to store intermediate value\n  const intermediate = useRef(null);\n  const wrappedSetDimensions = (index, dimension) => {\n    const newDimensions = [\n      ...((intermediate && intermediate.current) || dimensions)\n    ];\n    const { width, height } = dimension.scroll;\n    newDimensions[index] = { width, height };\n    intermediate.current = newDimensions;\n    setDimension(newDimensions);\n  };\n  return [dimensions, wrappedSetDimensions];\n};\n","export function initializeDimensions({\n  axis,\n  itemHeight,\n  averageItemHeight,\n  batchSize,\n  itemsCount\n}) {\n  return () => {\n    const totalBatches = Math.ceil(itemsCount / batchSize);\n    const estimatedEmptyBatchHeight =\n      axis === \"y\"\n        ? Math.ceil((itemHeight || averageItemHeight) * batchSize)\n        : // TODO - handle other directions\n          0;\n    const initial = [];\n    for (let i = 0; i < totalBatches; i += 1) {\n      initial[i] = { height: estimatedEmptyBatchHeight, width: null };\n    }\n    return initial;\n  };\n}\n","import { useState } from \"react\";\n\nexport function useVisibility(initial = []) {\n  const [visibility, setVisibility] = useState(initial);\n\n  const wrappedSetVisibility = newVisibility => {\n    setVisibility(newVisibility);\n  };\n\n  return [visibility, wrappedSetVisibility];\n}\n","export function initializeInitialVisibility({\n  axis,\n  containerHeight,\n  itemHeight,\n  averageItemHeight,\n  batchSize,\n  itemsCount\n}) {\n  return () => {\n    const totalBatches = Math.ceil(itemsCount / batchSize);\n    const estimatedInitialBatches =\n      axis === \"y\"\n        ? Math.ceil(\n            containerHeight / ((itemHeight || averageItemHeight) * batchSize)\n          )\n        : // TODO - handle other directions\n          0;\n    const initial = [];\n    for (let i = 0; i < totalBatches; i += 1) {\n      initial[i] = i < estimatedInitialBatches;\n    }\n    return initial;\n  };\n}\n","import { useEffect, useRef, useState } from \"react\";\nimport throttle from \"lodash.throttle\";\n\nconst getScrollOffset = (element, axis) => {\n  const { scrollTop, scrollY } = element;\n  if (axis === \"y\") {\n    if (scrollTop !== undefined) {\n      return scrollTop;\n    }\n    return scrollY;\n  }\n  return 0;\n};\n\nexport const useScroll = ({ root, axis }) => {\n  const timeout = useRef(null);\n  const [scrollOffset, setScrollOffset] = useState(0);\n\n  useEffect(() => {\n    const element = root || window;\n    const handler = throttle(() => {\n      // If there's a timer, cancel it\n      if (timeout.current) {\n        window.cancelAnimationFrame(timeout.current);\n      }\n      // Setup the requestAnimationFrame\n      timeout.current = window.requestAnimationFrame(() =>\n        setScrollOffset(getScrollOffset(element, axis))\n      );\n    }, 100);\n    element.addEventListener(\"scroll\", handler, {\n      capture: false,\n      passive: true\n    });\n\n    return () => {\n      if (handler.cancel) {\n        handler.cancel();\n      }\n      window.cancelAnimationFrame(timeout.current);\n      element.removeEventListener(\"scroll\", handler);\n    };\n  }, [axis, root]);\n\n  return scrollOffset;\n};\n","import { useEffect } from \"react\";\nimport { useDimensions } from \"./useDimensions\";\nimport { initializeDimensions } from \"./initializeDimensions\";\nimport { useVisibility } from \"./useVisibility\";\nimport { initializeInitialVisibility } from \"./initializeInitialVisibility\";\nimport { useScroll } from \"./useScroll\";\n\n// Time interval B 'overlaps' A if:\n// B starts after A starts but before A finishes.\n// B starts before A starts and finishes after A starts.\nfunction areOverlapping(A, B) {\n  if (B[0] < A[0]) {\n    return B[1] > A[0];\n  }\n  return B[0] < A[1];\n}\n\nexport const useVisibilityAndDimension = ({\n  root,\n  axis,\n  containerHeight,\n  itemsCount,\n  itemHeight,\n  averageItemHeight,\n  batchSize,\n  batchBufferDistance\n}) => {\n  const [dimensions, setDimension] = useDimensions(\n    initializeDimensions({\n      itemsCount,\n      axis,\n      itemHeight,\n      averageItemHeight,\n      batchSize\n    })\n  );\n  const [visibility, setVisibility] = useVisibility(\n    initializeInitialVisibility({\n      itemsCount,\n      axis,\n      containerHeight,\n      itemHeight,\n      averageItemHeight,\n      batchSize\n    })\n  );\n  const scrollOffset = useScroll({ root, axis });\n\n  useEffect(() => {\n    const renderWindow = [\n      scrollOffset - batchBufferDistance,\n      scrollOffset + containerHeight + batchBufferDistance\n    ];\n    const totalBatches = Math.ceil(itemsCount / batchSize);\n\n    let nextTotal = 0;\n    const nextVisibility = [];\n    for (let i = 0; i < totalBatches; i += 1) {\n      const currentHeight = nextTotal;\n      const nextHeight = nextTotal + dimensions[i].height;\n      nextVisibility[i] = areOverlapping(renderWindow, [\n        currentHeight,\n        nextHeight\n      ]);\n      nextTotal = nextHeight;\n    }\n\n    const visibilityChanged = nextVisibility.some(\n      (e, i) => e !== visibility[i]\n    );\n    if (visibilityChanged) {\n      setVisibility(nextVisibility);\n    }\n  }, [\n    batchSize,\n    containerHeight,\n    setVisibility,\n    dimensions,\n    itemsCount,\n    scrollOffset,\n    visibility,\n    batchBufferDistance\n  ]);\n\n  return [dimensions, visibility, setDimension];\n};\n","export const getVisibleIndexes = visibility => {\n  let start;\n  let end;\n\n  for (let i = 0; i < visibility.length; i += 1) {\n    const v = visibility[i];\n    if (start !== undefined && end !== undefined && !v) {\n      break;\n    }\n    if (start === undefined && v) {\n      start = i;\n    }\n    if (start !== undefined && v) {\n      end = i;\n    }\n  }\n\n  return [start, end];\n};\n","import React, { useRef, useEffect } from \"react\";\n\nexport const Sentinel = ({\n  fetchMoreBufferDistance,\n  onFetchMore,\n  RenderLoader,\n  wrapperElement,\n  items,\n  itemsCount,\n  batchSize,\n  root,\n  axis\n}) => {\n  const ref = useRef(null);\n\n  useEffect(() => {\n    const targetNode = ref.current;\n    const options = {\n      root,\n      rootMargin:\n        axis === \"y\" ? `0px 0px ${fetchMoreBufferDistance}px 0px` : \"0px\",\n      threshold: 0\n    };\n    const callback = ([{ isIntersecting }]) => {\n      if (isIntersecting) {\n        onFetchMore({ items, itemsCount, batchSize });\n      }\n    };\n    const observer = new IntersectionObserver(callback, options);\n    if (targetNode) {\n      observer.observe(targetNode);\n    }\n\n    return () => {\n      // Stop watching all of its target elements for visibility changes\n      observer.disconnect();\n    };\n  }, [\n    axis,\n    fetchMoreBufferDistance,\n    batchSize,\n    items,\n    onFetchMore,\n    root,\n    itemsCount\n  ]);\n\n  return React.createElement(\n    wrapperElement,\n    {\n      ref\n    },\n    <RenderLoader items={items} itemsCount={itemsCount} batchSize={batchSize} />\n  );\n};\n","/**\n * TODO:\n * - Unmount cards?\n * - Use scrollRestoration to reduce batch creation - https://itsze.ro/blog/2017/04/09/infinite-list-and-react.html\n * - Scroll restoration\n * - Optimize every piece of code\n * - Custom element scroll\n * - More stories\n * - Multiple axis support\n * - Testing\n * - Animatable card story\n */\n\n/**\n * Things learnt\n * React.memo re-renders when context is used\n *   - https://github.com/facebook/react/issues/15156\n * Use requestAnimationFrame instead of throttle on scroll\n *   - https://gist.github.com/paulmillr/3118943\n *   - https://gomakethings.com/debouncing-events-with-requestanimationframe-for-better-performance/\n * react remounts rendered node when ref and functional component reference change in render\n */\nimport React, { memo } from \"react\";\nimport useWindowSize from \"@rehooks/window-size\";\nimport { getBatchedItems } from \"./getBatchedItems\";\nimport { BatchRenderer } from \"./BatchRenderer\";\nimport { useVisibilityAndDimension } from \"./useVisibilityAndDimension\";\nimport { getVisibleIndexes } from \"./getVisibleIndexes\";\nimport { Sentinel } from \"./Sentinel\";\n\nconst DelightfulScroller = ({\n  containerHeight,\n  items,\n  RenderItem,\n  getItemKey,\n  wrapperElement,\n  forwardRef,\n  RenderContainer,\n  removeFromDOM,\n  root,\n  batchSize,\n  axis,\n  averageItemHeight,\n  itemHeight,\n  itemsCount,\n  batchBufferDistance,\n  onFetchMore,\n  RenderLoader,\n  fetchMoreBufferDistance\n}) => {\n  const [dimensions, visibility, setDimension] = useVisibilityAndDimension({\n    root,\n    axis,\n    containerHeight,\n    itemsCount,\n    itemHeight,\n    averageItemHeight,\n    batchSize,\n    batchBufferDistance\n  });\n\n  const batchedItems = getBatchedItems(items, batchSize);\n  let current = batchedItems;\n  let previous = [];\n  let next = [];\n  let prevHeight;\n  let nextHeight;\n\n  if (removeFromDOM) {\n    const [startIndex, endIndex] = getVisibleIndexes(visibility);\n    previous = batchedItems.slice(0, startIndex);\n    current = batchedItems.slice(startIndex, endIndex + 1);\n    next = batchedItems.slice(endIndex + 1, batchedItems.length);\n\n    prevHeight = previous.reduce((p, c, i) => {\n      const index = i;\n      const dimension = dimensions[index];\n      return p + dimension.height;\n    }, 0);\n\n    nextHeight = next.reduce((p, c, i) => {\n      const index = previous.length + current.length + i;\n      const dimension = dimensions[index];\n      return p + dimension.height;\n    }, 0);\n  }\n\n  const batchedElements = current.map((batch, i) => {\n    const index = previous.length + i;\n    return (\n      <BatchRenderer\n        key={index}\n        batch={batch}\n        index={index}\n        getItemKey={getItemKey}\n        batchSize={batchSize}\n        wrapperElement={wrapperElement}\n        removeFromDOM={removeFromDOM}\n        setDimension={setDimension}\n        RenderItem={RenderItem}\n        dimensions={dimensions[index]}\n        visible={visibility[index]}\n        itemHeight={itemHeight}\n      />\n    );\n  });\n\n  const Container = (\n    <RenderContainer forwardRef={forwardRef}>\n      {prevHeight ? (\n        <div style={{ height: prevHeight, visibility: \"hidden\" }} />\n      ) : null}\n      {batchedElements}\n      {nextHeight ? (\n        <div style={{ height: nextHeight, visibility: \"hidden\" }} />\n      ) : null}\n      {axis === \"y\" && items.length < itemsCount ? (\n        <Sentinel\n          onFetchMore={onFetchMore}\n          fetchMoreBufferDistance={fetchMoreBufferDistance}\n          RenderLoader={RenderLoader}\n          wrapperElement={wrapperElement}\n          items={items}\n          itemsCount={itemsCount}\n          batchSize={batchSize}\n          root={root}\n          axis={axis}\n        />\n      ) : null}\n    </RenderContainer>\n  );\n\n  return Container;\n};\n\nDelightfulScroller.displayName = \"DelightfulScroller\";\n\nconst DefaultRenderContainer = ({ children, forwardRef }) => (\n  <div ref={forwardRef}>{children}</div>\n);\n\nDefaultRenderContainer.displayName = \"DefaultRenderContainer\";\n\n// eslint-disable-next-line no-unused-vars\nconst DefaultRenderItem = ({ item, index }) => item;\n\nDefaultRenderItem.displayName = \"DefaultRenderItem\";\n\nDelightfulScroller.defaultProps = {\n  /** Items to render */\n  items: [],\n  /** Total number of items to render */\n  itemsCount: 0,\n  /** Item renderer component */\n  RenderItem: DefaultRenderItem,\n  /** Get unique key for every item, used to detect item value change */\n  getItemKey: (item, index) => (typeof item === \"string\" ? item : index),\n  /** HTML tag used to wrap each rendered item and sentinel */\n  wrapperElement: \"div\",\n  /** Container node renderer component */\n  RenderContainer: DefaultRenderContainer,\n  removeFromDOM: true,\n  /** Scroll parent - should be an element */\n  root: null,\n  averageItemHeight: 10, // Average item height should be min 1px\n  itemHeight: null, // Fixed item height(Optional)\n  axis: \"y\",\n  batchSize: 10, // Batch items into batch of n elements\n  batchBufferDistance: 250, // Batch buffer distance on both sides in px\n  fetchMoreBufferDistance: 500, // fetch more buffer distance on both sides in px\n  // eslint-disable-next-line no-unused-vars\n  onFetchMore: ({ items, itemsCount, batchSize }) => {},\n  // eslint-disable-next-line no-unused-vars\n  RenderLoader: ({ items, itemsCount, batchSize }) => null\n};\n\nconst WindowContainer = props => {\n  const { innerWidth, innerHeight } = useWindowSize();\n\n  return (\n    <DelightfulScroller\n      {...props}\n      containerWidth={innerWidth}\n      containerHeight={innerHeight}\n    />\n  );\n};\n\nconst DelightfulScrollerBase = (props, ref) => {\n  if (!props.root) {\n    return <WindowContainer {...props} forwardRef={ref} />;\n  }\n\n  // TODO - Custom container\n  return null;\n};\n\nDelightfulScrollerBase.displayName = \"DelightfulScrollerBase\";\n\nexport default memo(React.forwardRef(DelightfulScrollerBase));\n"],"names":["getBatchedItems","items","batchSize","batched","index","length","chunk","slice","push","Wrapper","React","forwardRef","ref","as","style","children","createElement","displayName","RenderItemWrapper","memo","item","RenderItem","BatchRenderer","batch","getItemKey","wrapperElement","removeFromDOM","dimensions","setDimension","visible","hasFixedHeightItems","itemHeight","batchWrapper","map","idx","actualIndex","key","itemsBatch","visibility","Measure","scroll","onResize","contentRect","measureRef","cloneElement","height","prevBatch","prevVisible","every","e","i","useDimensions","initialValue","useState","intermediate","useRef","wrappedSetDimensions","dimension","newDimensions","current","width","initializeDimensions","axis","averageItemHeight","itemsCount","totalBatches","Math","ceil","estimatedEmptyBatchHeight","initial","useVisibility","setVisibility","newVisibility","initializeInitialVisibility","containerHeight","estimatedInitialBatches","getScrollOffset","element","scrollTop","scrollY","undefined","useScroll","root","timeout","scrollOffset","setScrollOffset","useEffect","window","handler","throttle","cancelAnimationFrame","requestAnimationFrame","addEventListener","capture","passive","cancel","removeEventListener","areOverlapping","A","B","useVisibilityAndDimension","batchBufferDistance","renderWindow","nextTotal","nextVisibility","currentHeight","nextHeight","some","getVisibleIndexes","start","end","v","Sentinel","fetchMoreBufferDistance","onFetchMore","RenderLoader","targetNode","options","rootMargin","threshold","observer","IntersectionObserver","isIntersecting","observe","disconnect","DelightfulScroller","prevHeight","RenderContainer","batchedItems","previous","next","startIndex","endIndex","reduce","p","c","batchedElements","DefaultRenderContainer","DefaultRenderItem","defaultProps","WindowContainer","props","useWindowSize","innerWidth","innerHeight","containerWidth","DelightfulScrollerBase"],"mappings":"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"}